from utils import get_logger

logger = get_logger(__name__)


def get_neighbs(coords, rows):
    i, j = coords
    char = rows[i][j]
    if char == "x":
        ns = [(i - 1, j - 1), (i - 1, j + 1), (i + 1, j - 1), (i + 1, j + 1)]
    elif char == "+":
        ns = [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]
    yield from filter(
        lambda xs: 0 <= xs[0] < len(rows)
        and 0 <= xs[1] < len(rows[0])
        and rows[xs[0]][xs[1]] in ("x", "+"),
        ns,
    )


def kosaraju(grid):
    rows = grid.split("\n")
    pre = {}
    post = []
    stack = []
    reverse = {}

    def dfs(coords):
        pre[coords] = len(pre)
        stack.append(coords)
        for n in get_neighbs(coords, rows):
            reverse.setdefault(n, set()).add(coords)
            if n not in pre:
                dfs(n)
        while stack:
            n = stack.pop()
            post.append(n)
            if n == coords:
                break

    for i, row in enumerate(rows):
        for j, char in enumerate(row):
            if char in ("x", "+") and (i, j) not in pre:
                dfs((i, j))

    stack.clear()
    seen = set()
    count = 0
    logger.debug("post = %s (length %s)", post, len(post))
    while post:
        root = post.pop()
        if root in seen:
            logger.debug("root %s already seen", root)
            continue
        stack.append(root)
        while stack:
            elem = stack.pop()
            seen.add(elem)
            for n in reverse.get(elem, []):
                if n not in seen:
                    stack.append(n)
        count += 1
    logger.debug(reverse)
    return count


def tarjan(grid):
    """TODO: Debug this"""
    rows = grid.split("\n")
    pre = {}
    low = {}
    comps = {}
    reverse_dag = {}

    stack = []
    temp = set()

    def dfs(coords):
        lowest = low[coords] = pre[coords] = len(pre)
        stack.append(coords)
        for n in get_neighbs(coords, rows):
            if n not in pre:
                dfs(n)
            if n in comps:
                temp.add(comps[n])
            lowest = min(lowest, low[n])
        if lowest < low[coords]:
            low[coords] = lowest
            return
        while temp:
            reverse_dag.setdefault(temp.pop(), []).append(coords)
        while stack:
            n = stack.pop()
            comps[n] = coords
            low[n] = float("inf")
            if n == coords:
                break

    for i, row in enumerate(rows):
        for j, char in enumerate(row):
            if char in ("x", "+") and (i, j) not in pre:
                dfs((i, j))

    logger.debug("comps = %s", comps)
    logger.debug("reverse_dag = %s", reverse_dag)
    logger.debug("pre = %s", pre)
    return len([c for c, p in reverse_dag if not p])


def min_bombs_needed(grid):
    rows = grid.split("\n")
    fringe = set()
    internal = set()

    for i, row in enumerate(rows):
        for j, char in enumerate(row):
            if char in ("+", "x"):
                if (i, j) not in internal:
                    logger.debug("Adding fringe elem %s with bomb %s", (i, j), char)
                    fringe.add((i, j))
                for n in get_neighbs((i, j), rows):
                    internal.add(n)
                    fringe.discard(n)

    logger.debug("fringe = %s", fringe)
    logger.debug("internal = %s", internal)
    return len(fringe)


def connected_components(grid):
    """This doesn't work because it ignore the directionality of edges."""
    rows = grid.split("\n")
    bombs = {
        (i, j): (i, j)
        for i, row in enumerate(rows)
        for j, s in enumerate(row)
        if s in ("+", "x")
    }
    comps = set(bombs.keys())

    def get_component_root(coords):
        while bombs[coords] != coords:
            coords = bombs[coords]
        return coords

    for coords in bombs.keys():
        for n in get_neighbs(coords, rows):
            root = get_component_root(n)
            bombs[root] = bombs[n] = coords
            comps.discard(root)
        comps.add(coords)
    return len(comps)
